%-------------------------------------------------------------------------------
\section{Related Work}
%-------------------------------------------------------------------------------

\ash{
Post factum analysis of traces is important because they contain useful information like causality of events, resource consumption, errors, performance data and labeled metdata about components involved in the execution.
In large systems the size of the traces makes it impractical for a developer to do any manual analysis. This motivates the need for automated analysis of large corpus of traces to derive useful insights.
There are many goals for analysis for traces, including finding performance bottlenecks, system recovery \& repair, debugging, resource usage, service degradation analysis.
Many of these use cases use some form of classification or clustering. We descrobe some of the prior work in this area and highlight the drawbacks and explain how our approach overcomes some of the hurdles.
}

\ash{
Magpie \cite{Barham:2003:MOM:1251054.1251069} relies on structured events produced logged by ETW (event tracing for windows) inorder to avoid the need to have unique identifiers for every request.
Magpie correlates events generated by the application, middleware and operating system using temporal joins to infer causal relationships. 
Magpie uses a comparison based on a simple string-edit-distance metric on flattened execution graphs as a basis for execution clustering.
Even though the technique shows promising results even for classification of requests with differences in internal concurrency structures, the authors acknowledge the need for graph and tree edit distances.
}

\ash{
Spectroscope \cite{Sambasivan:2011:DPC:1972457.1972463} collects execution traces represented as process invocation trees, and diagnoses performance
changes by comparing sets of before- and aftertraces. Spectroscope assumes that a similar workload was run before and after the performance change, and that the performance change manifests as a change in distribution
over the request structures and/or request timings. To diagnose a change, spectroscope compares the distributions of service completion times for graphs that are topologically identical, and compares structural differences
between executions using string-edit-distance.
}

\ash{
    Mann et al. \cite{Mann:2011:MPE:2170444.2170464} collect execution traces from datacenter
services, and model the latency of a service given the
child services invoked. The execution graphs recorded
do not fully capture the causal dependencies internal to a
service, so one component of the work is to deduce those
causal dependencies from a collection of training examples.
The training examples are then clustered if they
have identical execution graphs. At runtime, a cluster is
selected by comparing its service timings with the cluster
centroids, and selecting the nearest-neighbour. A prediction
for the executionâ€™s overall runtime is then given
based on the other executions in the selected cluster.
}