%-------------------------------------------------------------------------------
\section{Introduction}
%-------------------------------------------------------------------------------
Tracing is increasing being used in industry~\cite{Jegeur, Zipkin, 36356} and has been shown to be useful in finding the causes of performance problems~\cite{36356, Fonseca:2007:XPN:1973430.1973450, Reynolds:2006:PDU:1267680.1267689, DBLP:conf/sigmetrics/ThereskaSSWALG06, Sambasivan:2011:DPC:1972457.1972463}, anomaly detection~\cite{Barham:2003:MOM:1251054.1251069, Chen:2004:PFE:1251175.1251198, 37477, Sambasivan:2011:DPC:1972457.1972463} as well as to model workloads, resource usage and timings~\cite{37520, Chanda:2007:WTP:1272996.1273001, 36356, DBLP:conf/sigmetrics/ThereskaSSWALG06, Barham:2003:MOM:1251054.1251069}.  The opentracing standardization effort~\cite{OpenTracing} suggests that tracing is gaining traction.
\kam{I looked the the paper from SoCC 2018 to get a few references and ended up paraphrasing a few lines from the intro. Is that a problem? Specifically, the weighted sampling paper}

Individual services have always been augmented with logging and telemetry but they alone cannot reconstruct the elaborate journey of a request across any distributed system. Initially distributed tracing was confined to micro-services. There has been a proliferation of tracing into components like databases, queues, proxies, cache~\cite{OpenTracingCassandra, OpenTracingKafka, OpenTracingRedis}. This has led to complete end to end tracing in distributed systems. This enables developers to look at end-to-end properties of a system over multiple executions.

Consider debugging a failure in a distributed system. To debug a problem in production, it is insufficient to merely obtain a trace. What would be useful is to clearly identify what distinguishes the failed execution from a successful execution. But wait, to be actually useful we would need to compare the trace of the failed execution with the trace of a successful execution that exercises the same path in the system. In order to use tracing effectively for debugging, we need to be able to compare graphs in two different ways:
\begin{itemize}
\item Identifying the request path, let's call them classes, of traces by comparing graphs with one another. This is the classic classification problem.
\item Differencing of trace of a failed execution from that of successful execution(s) in the same class.
\end{itemize}

Consider another scenario. We have a failure in a distributed system for which we have a trace. We now want to check our stored traces to determine if a similar failure has been seen before. Distributed tracing systems like Dapper, perform uniform sampling at very low rates to keep the cost of storing traces low. As a consequence, the long tail of distributed executions is not captured. This tail contains the traces which are symptomatic of edge cases like slow queries, one-off execution paths that are infrequent but imperative for identifying the bottlenecks and improving the system. In order to be able to answer this question, we need to techniques to compare graphs with one another:
\begin{itemize}
\item To identify graphs that are different from each other in order to store traces that appear infrequently.
\item To identify graphs that are similar to each other and quantify this similarity. 
\end{itemize}

Therefore, in order for tracing to achieve its full potential, we need to couple tracing with graph comparison techniques. In particular, we need to define two quantities:
\begin{itemize}
\item Trace embedding: \newline
Given a graph, G=(V,E), a trace embedding is a map M, such that \newline
$M\colon G \rightarrow TE$, where $TE \in String, R^{d}$
\item Distance measure to compute distances between the embeddings
\end{itemize}
Prior work~\cite{Barham:2003:MOM:1251054.1251069, Sambasivan:2011:DPC:1972457.1972463} use flattening the graph generated by a trace as embedding and string-edit distance as distance measure to compare graphs. More recently, Las-Casas et al.~\cite{Las-Casas:2018:WSE:3267809.3267841} use a node-based array as embedding, where each distinct node is represented as an entry in the array and euclidean distance for the distance measure. While their results seem promising, a different trace embedding may be necessary based on the characteristics of the graphs or problem under consideration. The issue is that all of the embeddings have been generated by using domain knowledge about the traces and the problem it is going to be used for. 

However, given the knowledge that embeddings which capture structural information from the graph can be used in a wide variety of problems similar to the two described above, can we learn general purpose trace embeddings automatically from the data? Turns out, we can. Representational learning emerged to address the problem of feature engineering for graphs before machine learning tasks can be applied. A recent survey paper by Hamilton et al.~\cite{corr_2017_abs-1709-05584} points out that prior work on feature engineering involved extracting summary information from graphs, graph kernels or carefully engineered features to measure local neighborhood structures. 

Representational learning is attractive for two reasons: It is data-driven and does not depend on feature engineering, unlike prior approaches; nodes or entire graphs are embedded in a low dimensional space $R^{d}$, such that the geometric relationships in the vector space reflect the structure of the original graph. Representational learning techniques have been used in diverse fields such as social network analysis and molecular biology. We are the first to demonstrate their applications to distributed systems. 

Our contributions include:
\begin{itemize}
\item Representational learning far outperforms a naive approach \kam{Work in progress. Claim as yet unproven }
\item Provide initial results of the use of graph representations for a variety of use cases as hinting at possible causes of failures, classification and clustering.
\end{itemize}

\kam{I tried to incorporate graph generation, but I could not think of an application. Maybe we should discuss?}

